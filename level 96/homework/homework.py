    # 1

# str data is immutable because we cannot replace elements of both lists and strings without using 
# certain methods 
# directly using the index, otherwise the program will throw an error.


    # 2

# String data is immutable if we use index but if we use 
# certain string methods like replace() then it helps us not 
# to replace the string but to return a new already modified string directly. 
# Replacing a string is an error while 
# replace() method returns a new string which is already modified.


    # 3

# Not all data types are valid, only tuple is invalid because we create a tuple with 
# brackets like {} instead of ()


    # 4

# The sentence "i created function" is not correct because programming has its own verbal 
# syntax. In this case, instead of created, it would be declared. Both have the same meaning, 
# but in programming we say declared rather than created.

    # 5

# Yes, Python is a case-sensitive language because Python treats "a" and "A" as different elements.


    # 6

# print(True + True) will output 2 because when we use logical operators like "and" and "or" 
# with their help the answer is always boolean but when we perform mathematical operation between 
# booleans it will not output boolean and in this case it will 
# output 2 because True is considered as 1 and False is considered as 0.


    # 7

# print("1_000_000") will output 1000000 because when we convert a number to an integer 
# and the number is mixed with string elements, it outputs an error. But when we write "_" 
# it simply divides the numbers and the program does not perceive the string elements 
# while converting to integer and 
# converts the number to integer data type without any problems.


    # 8

# b,a,d,c = (1,2,3,4)
# print(a)

# This code will output 2 because we have created several variables on one line, each of 
# whose values ​​are elements of a tuple, where the 
# value a is the second element in the tuple, i.e. 2.


    # 9

# An empty list is of course False because nothing is given in the list, and anything 
# that is an empty list, tuple, string, or dict is False.


    # 10

# a,b = 1,2
# a,b = b,a
# print(a,b)

# This code will output 2 1 because we have changed the values ​​of 
# the variable so to speak, we have reversed it, and it will output 2 1 
# and not 2,1 because when we print some information in the terminal using 
# the print() function and we divide these elements by , this is like the distance 
# between these elements when we print all this in the terminal.


    # 11

# Yes, we can create a list comprehension with an if statement because the syntax allows 
# it, but when using a list comprehension with an if statement, 
# the if statement must be written at the end like this: [i for i in arr if i >= 5].


    # 12

# Yes, we can create a list comprehension with if/else statement because this 
# is possible with the syntax, but when we use a list comprehension with if/else
# statement, the if/else statement must be written before the for loop, otherwise 
# it will throw a syntax error, 
# for example: ["odd" if i % 2 == 1 else "even" for i in arr].


    # 13

# Yes, we can create a function within a function and we can use the created 
# function anytime we want and whenever we want. We have this ability in Python 
# and it is also syntactically permissible. 
# This is the same as using built-in functions in costume functions.


    # 14

# In Python, we have many types of errors, one of which is zeroDivisionError. 
# This is an error that occurs when we 
# divide a certain number by zero or divide zero by any number.


    # 15

# Lambda functions are called anonymous functions because we can use them only once.


    # 16 

# Lambda functions are called anonymous functions because we can use them only once


    # 17

# print(not "") will return True because all voids such as empty string, list, dict, 
# tuple, set, etc. are treated as False, while the not keyword always returns the opposite 
# answer with booleans, for example, not True will return False, while not False will return 
# True, while an empty string is False, 
# and not False is the same as True, so this code will return True.


    # 18

# When someone says that everything is an object in Python, it would be true because 
# in Python, everything is indeed an object. For example, data types when we return their 
# data type through the type() function, it returns objects such as: 
# <class "int">, <class "str">, <class "bool">, <class "float">, etc.


    # 19

# is and == are not the same operators == checks whether the objects are of the same 
# data type or not with the same value. For example a = [1,2,3,4] b = [1,2,3,4] a == b 
# will return True but if we write a is b it will return False because the is operator 
# checks whether the objects are the same i.e. in this case both represent the same memory address or not. 
# In this case it returns False because both lists are stored in different variables.


    # 20

# Python is a high-level programming language because high-level programming languages ​
# ​are not close to computer languages, so to speak, simple languages ​​are called high-level 
# programming languages. Therefore, since Python 
# is a simple language, it is a high-level programming language.